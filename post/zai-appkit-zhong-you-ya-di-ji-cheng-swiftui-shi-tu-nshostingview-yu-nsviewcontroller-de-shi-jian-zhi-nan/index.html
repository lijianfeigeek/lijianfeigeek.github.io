<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南 | lijianfei.com</title>
<link rel="shortcut icon" href="https://lijianfei.com/favicon.ico?v=1761120781074">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lijianfei.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南 | lijianfei.com - Atom Feed" href="https://lijianfei.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<script id="chatway" async="true" src="https://cdn.chatway.app/widget.js?id=laNLrbQJYsup"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5152652314157130"
     crossorigin="anonymous">
</script>

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "m0j4678d23");
</script>
     


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74398720-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74398720-1');
</script>


    <meta property="og:title" content="在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南">
    <meta property="og:description" content="在macOS应用开发中，AppKit作为传统的UI框架，提供了强大的原生功能和精细的控制能力。而SwiftUI作为苹果推出的现代声明式UI框架，以其简洁的语法和跨平台特性受到开发者青睐。如何在现有的AppKit应用中无缝集成SwiftUI视...">
    <meta property="og:type" content="源码阅读">
    <meta property="og:url" content="https://lijianfei.com/post/zai-appkit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-nshostingview-yu-nsviewcontroller-de-shi-jian-zhi-nan/">
    <meta property="og:image" content="https://lijianfei.com/post-images/zai-appkit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-nshostingview-yu-nsviewcontroller-de-shi-jian-zhi-nan.png"/>
    <meta property="og:image:width" content="800">
    <meta property="og:image:height" content="500">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@lijianfei_com">
    <meta name="twitter:title" content="在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南">
    <meta name="twitter:image" content="https://lijianfei.com/post-images/zai-appkit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-nshostingview-yu-nsviewcontroller-de-shi-jian-zhi-nan.png">
    <meta name="twitter:image:width" content="800">

    <meta name="description" content="在macOS应用开发中，AppKit作为传统的UI框架，提供了强大的原生功能和精细的控制能力。而SwiftUI作为苹果推出的现代声明式UI框架，以其简洁的语法和跨平台特性受到开发者青睐。如何在现有的AppKit应用中无缝集成SwiftUI视..." />
    <meta name="keywords" content="源码阅读" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lijianfei.com">
  <img class="avatar" src="https://lijianfei.com/images/avatar.png?v=1761120781074" alt="">
  </a>
  <h1 class="site-title">
    lijianfei.com
  </h1>
  <p class="site-description">
    思危，思退，思变。<br>
追求进步，不求完美。<br>
做好小事，熬过难事，静成大事。<br>
语以泄败，事以密成，沉得住气，静得下心。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于我
        </a>
      
    
      
        <a href="https://github.com/lijianfeigeek" class="menu" target="_blank">
          Github
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
    <img src="https://ghchart.rshah.org/F15406/lijianfeigeek" style="max-width: 100%;height: auto;"/>
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南
            </h2>
            <div class="post-info">
              <span>
                2025-09-04
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://lijianfei.com/tag/yuan-ma-yue-du/" class="post-tag">
                  # 源码阅读
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://lijianfei.com/post-images/zai-appkit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-nshostingview-yu-nsviewcontroller-de-shi-jian-zhi-nan.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>在macOS应用开发中，AppKit作为传统的UI框架，提供了强大的原生功能和精细的控制能力。而SwiftUI作为苹果推出的现代声明式UI框架，以其简洁的语法和跨平台特性受到开发者青睐。如何在现有的AppKit应用中无缝集成SwiftUI视图，成为许多开发者面临的技术挑战。</p>
<p>本文以LunarBar项目中的<code>DateDetailsView</code>为例，深入探讨一种在AppKit环境中承载SwiftUI视图的优雅技术方案。</p>
<!-- more -->
<h2 id="技术方案概述">技术方案概述</h2>
<p>在LunarBar的<code>DateDetailsView.swift</code>中，我们看到了一个典型的AppKit与SwiftUI混合架构的实现：</p>
<pre><code>private final class DateDetailsHostVC: NSViewController {
  private let contentView: NSView

  init(rootView: DateDetailsView) {
    self.contentView = NSHostingView(rootView: rootView)
    super.init(nibName: nil, bundle: nil)
  }
}
</code></pre>
<p>这个架构的核心是<strong>NSHostingView</strong>，它是苹果官方提供的桥梁，用于在AppKit中托管SwiftUI视图。</p>
<h2 id="核心组件解析">核心组件解析</h2>
<h3 id="1-nshostingviewswiftui到appkit的桥梁">1. NSHostingView：SwiftUI到AppKit的桥梁</h3>
<p><code>NSHostingView</code>是AppKit框架中的关键类，它继承自<code>NSView</code>，专门用于在AppKit环境中显示SwiftUI视图：</p>
<pre><code>// 将SwiftUI视图包装在NSHostingView中
self.contentView = NSHostingView(rootView: rootView)
</code></pre>
<p><strong>主要特性：</strong></p>
<ul>
<li>自动处理SwiftUI视图的生命周期</li>
<li>传递AppKit的用户输入事件到SwiftUI视图</li>
<li>管理SwiftUI视图的布局和绘制</li>
<li>支持自动布局和约束系统</li>
</ul>
<h3 id="2-nsviewcontroller视图控制器模式">2. NSViewController：视图控制器模式</h3>
<p>通过<code>NSViewController</code>来管理SwiftUI视图的容器，提供了更好的架构组织和生命周期管理：</p>
<pre><code>private final class DateDetailsHostVC: NSViewController {
  // 私有属性确保封装性
  private let contentView: NSView
  
  init(rootView: DateDetailsView) {
    self.contentView = NSHostingView(rootView: rootView)
    super.init(nibName: nil, bundle: nil)
  }
}
</code></pre>
<p><strong>设计优势：</strong></p>
<ul>
<li><strong>封装性</strong>：<code>final class</code>防止继承，确保设计意图明确</li>
<li><strong>安全性</strong>：禁用<code>init(coder:)</code>防止从Storyboard意外实例化</li>
<li><strong>简洁性</strong>：使用<code>nibName: nil, bundle: nil</code>避免不必要的资源加载</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="1-视图层次结构构建">1. 视图层次结构构建</h3>
<p>在<code>loadView()</code>方法中，建立完整的视图层次结构：</p>
<pre><code>override func loadView() {
  view = NSView()
  view.addSubview(contentView)
  
  // 设置自动布局约束
  contentView.translatesAutoresizingMaskIntoConstraints = false
  NSLayoutConstraint.activate([
    contentView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
    contentView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
    contentView.topAnchor.constraint(equalTo: view.topAnchor),
    contentView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
  ])
}
</code></pre>
<p><strong>关键点：</strong></p>
<ul>
<li>创建根视图容器</li>
<li>将SwiftUI托管视图添加到容器中</li>
<li>使用Auto Layout约束确保SwiftUI视图填满整个容器</li>
</ul>
<h3 id="2-生命周期管理">2. 生命周期管理</h3>
<p>通过重写<code>NSViewController</code>的生命周期方法，实现特定的功能：</p>
<pre><code>override func viewWillAppear() {
  super.viewWillAppear()
  applyMaterial(AppPreferences.Accessibility.popoverMaterial)
}

override func viewDidLayout() {
  super.viewDidLayout()
  
  // 计算并设置首选内容大小
  var contentSize = contentView.fittingSize
  contentSize.width = min(
    Constants.maximumWidth * AppPreferences.General.contentScale.rawValue,
    contentSize.width
  )
  
  preferredContentSize = contentSize
}
</code></pre>
<p><strong>功能实现：</strong></p>
<ul>
<li><strong>视觉效果</strong>：在视图即将显示时应用材质效果</li>
<li><strong>尺寸管理</strong>：在布局完成后计算并限制内容视图的最大宽度</li>
<li><strong>响应式设计</strong>：支持内容缩放和动态尺寸调整</li>
</ul>
<h3 id="3-与nspopover的集成">3. 与NSPopover的集成</h3>
<p>整个SwiftUI视图最终被集成到<code>NSPopover</code>中，作为弹出式内容：</p>
<pre><code>static func createPopover(title: String, events: [EKCalendarItem], lineWidth: Double) -&gt; NSPopover {
  let popover = NSPopover()
  popover.behavior = .applicationDefined
  popover.animates = false
  popover.anchorHidden = true
  popover.contentViewController = DateDetailsHostVC(rootView: Self(
    title: title,
    events: events,
    lineWidth: lineWidth
  ))
  
  return popover
}
</code></pre>
<p><strong>配置要点：</strong></p>
<ul>
<li><code>behavior = .applicationDefined</code>：自定义弹出窗口行为</li>
<li><code>animates = false</code>：禁用动画提升性能</li>
<li><code>anchorHidden = true</code>：隐藏锚点保持界面简洁</li>
<li>通过<code>contentViewController</code>属性连接SwiftUI宿主控制器</li>
</ul>
<h2 id="技术优势">技术优势</h2>
<h3 id="1-架构清晰性">1. 架构清晰性</h3>
<ul>
<li><strong>职责分离</strong>：SwiftUI负责内容展示，AppKit负责容器管理</li>
<li><strong>模块化设计</strong>：宿主控制器封装了所有集成细节</li>
<li><strong>可维护性</strong>：代码结构清晰，便于后续维护和扩展</li>
</ul>
<h3 id="2-性能优化">2. 性能优化</h3>
<ul>
<li><strong>按需加载</strong>：SwiftUI视图只在需要时创建和显示</li>
<li><strong>内存管理</strong>：利用ARC自动管理内存，避免内存泄漏</li>
<li><strong>渲染效率</strong>：NSHostingView优化的渲染管道</li>
</ul>
<h3 id="3-用户体验">3. 用户体验</h3>
<ul>
<li><strong>无缝集成</strong>：用户无法感知底层框架的切换</li>
<li><strong>响应式交互</strong>：保持SwiftUI的响应式特性</li>
<li><strong>视觉效果</strong>：支持AppKit的视觉效果和材质</li>
</ul>
<h2 id="最佳实践建议">最佳实践建议</h2>
<h3 id="1-宿主控制器设计">1. 宿主控制器设计</h3>
<pre><code>// 使用final class防止继承
private final class SwiftUIViewHostVC: NSViewController {
  
  // 私有属性确保封装性
  private let hostingView: NSHostingView&lt;SomeSwiftUIView&gt;
  
  init(rootView: SomeSwiftUIView) {
    self.hostingView = NSHostingView(rootView: rootView)
    super.init(nibName: nil, bundle: nil)
  }
  
  @available(*, unavailable)
  required init?(coder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
}
</code></pre>
<h3 id="2-约束设置模式">2. 约束设置模式</h3>
<pre><code>override func loadView() {
  let container = NSView()
  let hostingView = NSHostingView(rootView: swiftUIView)
  
  container.addSubview(hostingView)
  hostingView.translatesAutoresizingMaskIntoConstraints = false
  
  NSLayoutConstraint.activate([
    hostingView.topAnchor.constraint(equalTo: container.topAnchor),
    hostingView.leadingAnchor.constraint(equalTo: container.leadingAnchor),
    hostingView.trailingAnchor.constraint(equalTo: container.trailingAnchor),
    hostingView.bottomAnchor.constraint(equalTo: container.bottomAnchor)
  ])
  
  view = container
}
</code></pre>
<h3 id="3-生命周期管理">3. 生命周期管理</h3>
<pre><code>override func viewWillAppear() {
  super.viewWillAppear()
  // 应用视觉效果
  setupVisualEffects()
}

override func viewDidLayout() {
  super.viewDidLayout()
  // 动态调整尺寸
  adjustContentSize()
}
</code></pre>
<h2 id="适用场景">适用场景</h2>
<p>这种技术方案特别适用于：</p>
<ol>
<li><strong>渐进式迁移</strong>：将现有AppKit应用逐步迁移到SwiftUI</li>
<li><strong>混合界面</strong>：在AppKit应用中集成特定的SwiftUI组件</li>
<li><strong>弹出式内容</strong>：如工具提示、详细信息弹窗等</li>
<li><strong>复杂视图</strong>：需要SwiftUI强大声明式能力的复杂UI组件</li>
</ol>
<h2 id="注意事项">注意事项</h2>
<h3 id="1-性能考虑">1. 性能考虑</h3>
<ul>
<li>避免在频繁更新的视图中使用此方案</li>
<li>考虑SwiftUI视图的复杂度对性能的影响</li>
<li>合理使用<code>@State</code>和<code>@ObservedObject</code>管理状态</li>
</ul>
<h3 id="2-平台兼容性">2. 平台兼容性</h3>
<ul>
<li>确保目标平台支持NSHostingView（macOS 10.15+）</li>
<li>考虑不同macOS版本的API差异</li>
<li>测试在不同系统版本下的表现</li>
</ul>
<h3 id="3-调试和测试">3. 调试和测试</h3>
<ul>
<li>使用Xcode的视图层次调试工具</li>
<li>确保约束正确设置，避免布局问题</li>
<li>测试不同窗口大小和缩放比例下的表现</li>
</ul>
<h2 id="结论">结论</h2>
<p>通过<code>NSHostingView</code>和<code>NSViewController</code>的结合使用，我们可以在AppKit应用中优雅地集成SwiftUI视图。这种技术方案不仅保持了代码的清晰性和可维护性，还为用户提供了无缝的使用体验。</p>
<p>LunarBar项目中的<code>DateDetailsView</code>实现展示了这种技术的最佳实践：清晰的架构、合理的生命周期管理、以及与现有AppKit组件的无缝集成。对于需要在AppKit应用中使用SwiftUI的开发者来说，这是一种值得推荐的技术方案。</p>
<p>随着SwiftUI的不断发展和完善，这种混合架构的应用场景将会越来越广泛。掌握这种技术，将帮助开发者更好地利用两个框架的优势，构建出更加优秀的macOS应用程序。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0">技术方案概述</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90">核心组件解析</a>
<ul>
<li><a href="#1-nshostingviewswiftui%E5%88%B0appkit%E7%9A%84%E6%A1%A5%E6%A2%81">1. NSHostingView：SwiftUI到AppKit的桥梁</a></li>
<li><a href="#2-nsviewcontroller%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F">2. NSViewController：视图控制器模式</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">实现细节</a>
<ul>
<li><a href="#1-%E8%A7%86%E5%9B%BE%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%9E%84%E5%BB%BA">1. 视图层次结构构建</a></li>
<li><a href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86">2. 生命周期管理</a></li>
<li><a href="#3-%E4%B8%8Enspopover%E7%9A%84%E9%9B%86%E6%88%90">3. 与NSPopover的集成</a></li>
</ul>
</li>
<li><a href="#%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8A%BF">技术优势</a>
<ul>
<li><a href="#1-%E6%9E%B6%E6%9E%84%E6%B8%85%E6%99%B0%E6%80%A7">1. 架构清晰性</a></li>
<li><a href="#2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">2. 性能优化</a></li>
<li><a href="#3-%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C">3. 用户体验</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE">最佳实践建议</a>
<ul>
<li><a href="#1-%E5%AE%BF%E4%B8%BB%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1">1. 宿主控制器设计</a></li>
<li><a href="#2-%E7%BA%A6%E6%9D%9F%E8%AE%BE%E7%BD%AE%E6%A8%A1%E5%BC%8F">2. 约束设置模式</a></li>
<li><a href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86">3. 生命周期管理</a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>
<ul>
<li><a href="#1-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91">1. 性能考虑</a></li>
<li><a href="#2-%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7">2. 平台兼容性</a></li>
<li><a href="#3-%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95">3. 调试和测试</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lijianfei.com/post/xiong-di-men-yi-ding-yao-yong-bao-ai/">
              <h3 class="post-title">
                兄弟们一定要拥抱 AI
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lijianfei.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
