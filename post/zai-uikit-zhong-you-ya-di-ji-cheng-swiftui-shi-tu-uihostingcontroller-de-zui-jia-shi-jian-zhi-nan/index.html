<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>在UIKit中优雅地集成SwiftUI视图：UIHostingController的最佳实践指南 | lijianfei.com</title>
<link rel="shortcut icon" href="https://lijianfei.com/favicon.ico?v=1761120781074">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lijianfei.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="在UIKit中优雅地集成SwiftUI视图：UIHostingController的最佳实践指南 | lijianfei.com - Atom Feed" href="https://lijianfei.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<script id="chatway" async="true" src="https://cdn.chatway.app/widget.js?id=laNLrbQJYsup"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5152652314157130"
     crossorigin="anonymous">
</script>

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "m0j4678d23");
</script>
     


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74398720-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74398720-1');
</script>


    <meta property="og:title" content="在UIKit中优雅地集成SwiftUI视图：UIHostingController的最佳实践指南">
    <meta property="og:description" content="Demo地址：lijianfeigeek/iOSUIKitSwiftUIExample: iOS平台上UIKit与SwiftUI混合架构的实现方案
在iOS应用开发中，UIKit作为成熟的UI框架，提供了强大的原生功能和精细的控制能力。而S...">
    <meta property="og:type" content="源码阅读">
    <meta property="og:url" content="https://lijianfei.com/post/zai-uikit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-uihostingcontroller-de-zui-jia-shi-jian-zhi-nan/">
    <meta property="og:image" content="https://lijianfei.com/post-images/zai-uikit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-uihostingcontroller-de-zui-jia-shi-jian-zhi-nan.png"/>
    <meta property="og:image:width" content="800">
    <meta property="og:image:height" content="500">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@lijianfei_com">
    <meta name="twitter:title" content="在UIKit中优雅地集成SwiftUI视图：UIHostingController的最佳实践指南">
    <meta name="twitter:image" content="https://lijianfei.com/post-images/zai-uikit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-uihostingcontroller-de-zui-jia-shi-jian-zhi-nan.png">
    <meta name="twitter:image:width" content="800">

    <meta name="description" content="Demo地址：lijianfeigeek/iOSUIKitSwiftUIExample: iOS平台上UIKit与SwiftUI混合架构的实现方案
在iOS应用开发中，UIKit作为成熟的UI框架，提供了强大的原生功能和精细的控制能力。而S..." />
    <meta name="keywords" content="源码阅读" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lijianfei.com">
  <img class="avatar" src="https://lijianfei.com/images/avatar.png?v=1761120781074" alt="">
  </a>
  <h1 class="site-title">
    lijianfei.com
  </h1>
  <p class="site-description">
    思危，思退，思变。<br>
追求进步，不求完美。<br>
做好小事，熬过难事，静成大事。<br>
语以泄败，事以密成，沉得住气，静得下心。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于我
        </a>
      
    
      
        <a href="https://github.com/lijianfeigeek" class="menu" target="_blank">
          Github
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
    <img src="https://ghchart.rshah.org/F15406/lijianfeigeek" style="max-width: 100%;height: auto;"/>
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              在UIKit中优雅地集成SwiftUI视图：UIHostingController的最佳实践指南
            </h2>
            <div class="post-info">
              <span>
                2025-09-04
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://lijianfei.com/tag/yuan-ma-yue-du/" class="post-tag">
                  # 源码阅读
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://lijianfei.com/post-images/zai-uikit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-uihostingcontroller-de-zui-jia-shi-jian-zhi-nan.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>Demo地址：<a href="https://github.com/lijianfeigeek/iOSUIKitSwiftUIExample">lijianfeigeek/iOSUIKitSwiftUIExample: iOS平台上UIKit与SwiftUI混合架构的实现方案</a></p>
<p>在iOS应用开发中，UIKit作为成熟的UI框架，提供了强大的原生功能和精细的控制能力。而SwiftUI作为苹果推出的现代声明式UI框架，以其简洁的语法和跨平台特性受到开发者青睐。在现有的UIKit应用中无缝集成SwiftUI视图，成为许多开发者面临的技术挑战。</p>
<p>本文将深入探讨iOS平台上UIKit与SwiftUI混合架构的实现方案，重点介绍<code>UIHostingController</code>的使用方法和最佳实践。</p>
<!-- more -->
<h2 id="技术方案概述">技术方案概述</h2>
<p>在iOS平台上，苹果提供了<code>UIHostingController</code>作为UIKit与SwiftUI之间的桥梁。与macOS的<code>NSHostingView</code>不同，iOS平台直接使用视图控制器来管理SwiftUI视图：</p>
<pre><code>private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  init(rootView: DateDetailsView) {
    super.init(rootView: rootView)
  }
  
  @available(*, unavailable)
  required init?(coder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
}
</code></pre>
<p>这个架构的核心是<strong>UIHostingController</strong>，它是苹果官方提供的视图控制器，专门用于在UIKit环境中管理SwiftUI视图。</p>
<h2 id="核心组件解析">核心组件解析</h2>
<h3 id="1-uihostingcontrollerswiftui到uikit的桥梁">1. UIHostingController：SwiftUI到UIKit的桥梁</h3>
<p><code>UIHostingController</code>是UIKit框架中的关键类，它继承自<code>UIViewController</code>，专门用于在UIKit环境中显示SwiftUI视图：</p>
<pre><code>// 直接继承UIHostingController并指定SwiftUI视图类型
private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  init(rootView: DateDetailsView) {
    super.init(rootView: rootView)
  }
}
</code></pre>
<p><strong>主要特性：</strong></p>
<ul>
<li>自动管理SwiftUI视图的生命周期</li>
<li>传递UIKit的用户输入事件到SwiftUI视图</li>
<li>支持自动布局和约束系统</li>
<li>提供视图控制器的完整生命周期管理</li>
</ul>
<h3 id="2-与macos方案的差异">2. 与macOS方案的差异</h3>
<p>与macOS的<code>NSHostingView</code>相比，iOS的<code>UIHostingController</code>有以下关键差异：</p>
<p><strong>macOS方案：</strong></p>
<pre><code>private final class DateDetailsHostVC: NSViewController {
  private let contentView: NSView
  
  init(rootView: DateDetailsView) {
    self.contentView = NSHostingView(rootView: rootView)
    super.init(nibName: nil, bundle: nil)
  }
}
</code></pre>
<p><strong>iOS方案：</strong></p>
<pre><code>private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  init(rootView: DateDetailsView) {
    super.init(rootView: rootView)
  }
}
</code></pre>
<p><strong>关键区别：</strong></p>
<ul>
<li>iOS直接继承<code>UIHostingController</code>，而macOS使用<code>NSViewController</code> + <code>NSHostingView</code></li>
<li>iOS的<code>UIHostingController</code>内置了SwiftUI视图的管理，无需手动创建宿主视图</li>
<li>iOS方案更简洁，减少了手动布局约束的设置</li>
</ul>
<h2 id="实现细节">实现细节</h2>
<h3 id="1-基本实现模式">1. 基本实现模式</h3>
<p>在iOS中实现SwiftUI视图的集成相对简单：</p>
<pre><code>import SwiftUI
import UIKit

// 定义SwiftUI视图
struct DateDetailsView: View {
  let title: String
  let events: [EKCalendarItem]
  let lineWidth: Double
  
  var body: some View {
    VStack {
      Text(title)
        .font(.headline)
      
      ForEach(events, id: \.self) { event in
        Text(event.title)
          .font(.subheadline)
      }
    }
    .padding()
  }
}

// 创建UIKit宿主控制器
private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    // 配置视图控制器属性
    view.backgroundColor = .systemBackground
    modalPresentationStyle = .formSheet
  }
  
  override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    
    // 动态调整首选内容大小
    preferredContentSize = view.systemLayoutSizeFitting(
      CGSize(width: view.bounds.width, height: UIView.layoutFittingCompressedSize.height)
    )
  }
}
</code></pre>
<h3 id="2-生命周期管理">2. 生命周期管理</h3>
<p><code>UIHostingController</code>继承自<code>UIViewController</code>，提供了完整的生命周期管理：</p>
<pre><code>private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    // 应用视觉效果
    setupVisualEffects()
  }
  
  override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    
    // 准备显示时的配置
    prepareForDisplay()
  }
  
  override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    
    // 视图完全显示后的操作
    startAnimations()
  }
  
  private func setupVisualEffects() {
    // 设置背景效果
    view.backgroundColor = .systemBackground
    
    // 设置圆角
    view.layer.cornerRadius = 12
    view.layer.masksToBounds = true
  }
}
</code></pre>
<h3 id="3-尺寸管理">3. 尺寸管理</h3>
<p>iOS中的尺寸管理比macOS更加自动化：</p>
<pre><code>private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()
    
    // 使用系统布局大小
    let fittingSize = view.systemLayoutSizeFitting(
      CGSize(
        width: UIScreen.main.bounds.width * 0.8,
        height: UIView.layoutFittingCompressedSize.height
      )
    )
    
    // 限制最大宽度
    let maxWidth = UIScreen.main.bounds.width * 0.9
    let finalSize = CGSize(
      width: min(fittingSize.width, maxWidth),
      height: fittingSize.height
    )
    
    preferredContentSize = finalSize
  }
}
</code></pre>
<h3 id="4-与uipopovercontroller的集成">4. 与UIPopoverController的集成</h3>
<p>在iOS中，SwiftUI视图可以轻松集成到各种容器中：</p>
<pre><code>static func createPopover(title: String, events: [EKCalendarItem], lineWidth: Double) -&gt; UIViewController {
  let hostingController = DateDetailsHostVC(
    rootView: DateDetailsView(
      title: title,
      events: events,
      lineWidth: lineWidth
    )
  )
  
  // 配置为弹出框
  hostingController.modalPresentationStyle = .popover
  hostingController.preferredContentSize = CGSize(width: 320, height: 400)
  
  // 配置弹出框委托
  hostingController.popoverPresentationController?.delegate = hostingController
  
  return hostingController
}
</code></pre>
<h2 id="高级特性">高级特性</h2>
<h3 id="1-uihostingcontrollersizingoptions">1. UIHostingControllerSizingOptions</h3>
<p>iOS 15+引入了<code>UIHostingControllerSizingOptions</code>，提供了更灵活的尺寸管理：</p>
<pre><code>private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    // 配置尺寸选项
    sizingOptions = [
      .intrinsicContentSize,
      .preferredContentSize
    ]
  }
}
</code></pre>
<p><strong>可用选项：</strong></p>
<ul>
<li><code>intrinsicContentSize</code>: 使用SwiftUI视图的固有内容大小</li>
<li><code>preferredContentSize</code>: 使用首选内容大小</li>
<li><code>automatic</code>: 自动选择最佳尺寸策略</li>
</ul>
<h3 id="2-uihostingconfiguration">2. UIHostingConfiguration</h3>
<p>iOS 16+引入了<code>UIHostingConfiguration</code>，用于在UIKit视图层次结构中嵌入SwiftUI视图：</p>
<pre><code>let hostingConfig = UIHostingConfiguration {
  Text(&quot;Hello from SwiftUI&quot;)
    .font(.title)
    .foregroundColor(.blue)
}

let label = UILabel()
label.configuration = hostingConfig
</code></pre>
<h3 id="3-双向通信">3. 双向通信</h3>
<p>实现UIKit与SwiftUI之间的双向通信：</p>
<pre><code>// 定义SwiftUI视图的观察者对象
class DateDetailsViewModel: ObservableObject {
  @Published var selectedEvent: EKCalendarItem?
  var onEventSelected: ((EKCalendarItem) -&gt; Void)?
  
  func selectEvent(_ event: EKCalendarItem) {
    selectedEvent = event
    onEventSelected?(event)
  }
}

// SwiftUI视图
struct DateDetailsView: View {
  @ObservedObject var viewModel: DateDetailsViewModel
  
  var body: some View {
    VStack {
      ForEach(viewModel.events, id: \.self) { event in
        Button(action: {
          viewModel.selectEvent(event)
        }) {
          Text(event.title)
        }
      }
    }
  }
}

// UIKit宿主控制器
private final class DateDetailsHostVC: UIHostingController&lt;DateDetailsView&gt; {
  private let viewModel: DateDetailsViewModel
  
  init(rootView: DateDetailsView, viewModel: DateDetailsViewModel) {
    self.viewModel = viewModel
    super.init(rootView: rootView)
    
    // 设置回调
    viewModel.onEventSelected = { [weak self] event in
      self?.handleEventSelection(event)
    }
  }
  
  private func handleEventSelection(_ event: EKCalendarItem) {
    // 处理事件选择
    print(&quot;Selected event: \(event.title)&quot;)
  }
}
</code></pre>
<h2 id="最佳实践建议">最佳实践建议</h2>
<h3 id="1-宿主控制器设计">1. 宿主控制器设计</h3>
<pre><code>// 使用final class防止继承
private final class SwiftUIViewHostVC: UIHostingController&lt;SomeSwiftUIView&gt; {
  
  // 可以添加额外的属性和方法
  private var additionalData: String?
  
  init(rootView: SomeSwiftUIView, additionalData: String? = nil) {
    self.additionalData = additionalData
    super.init(rootView: rootView)
  }
  
  @available(*, unavailable)
  required init?(coder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented&quot;)
  }
}
</code></pre>
<h3 id="2-生命周期管理-2">2. 生命周期管理</h3>
<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  
  // 配置基本属性
  setupAppearance()
  setupConstraints()
}

override func viewWillAppear(_ animated: Bool) {
  super.viewWillAppear(animated)
  
  // 准备显示
  prepareForDisplay()
}

override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)
  
  // 开始动画或其他交互
  startInteractions()
}
</code></pre>
<h3 id="3-尺寸和布局">3. 尺寸和布局</h3>
<pre><code>override func viewDidLayoutSubviews() {
  super.viewDidLayoutSubviews()
  
  // 动态调整尺寸
  adjustPreferredSize()
}

private func adjustPreferredSize() {
  let fittingSize = view.systemLayoutSizeFitting(
    CGSize(width: view.bounds.width, height: UIView.layoutFittingCompressedSize.height)
  )
  
  preferredContentSize = fittingSize
}
</code></pre>
<h2 id="适用场景">适用场景</h2>
<p>这种技术方案特别适用于：</p>
<ol>
<li><strong>渐进式迁移</strong>：将现有UIKit应用逐步迁移到SwiftUI</li>
<li><strong>混合界面</strong>：在UIKit应用中集成特定的SwiftUI组件</li>
<li><strong>弹出式内容</strong>：如详情弹窗、设置面板等</li>
<li><strong>复杂视图</strong>：需要SwiftUI强大声明式能力的复杂UI组件</li>
<li><strong>跨平台组件</strong>：需要在iOS和macOS上共享的UI组件</li>
</ol>
<h2 id="性能优化建议">性能优化建议</h2>
<h3 id="1-内存管理">1. 内存管理</h3>
<pre><code>private final class OptimizedHostingVC: UIHostingController&lt;ContentView&gt; {
  
  deinit {
    // 清理资源
    cleanupResources()
  }
  
  private func cleanupResources() {
    // 取消定时器、移除观察者等
  }
}
</code></pre>
<h3 id="2-渲染优化">2. 渲染优化</h3>
<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  
  // 启用光栅化以提高性能
  view.layer.shouldRasterize = true
  view.layer.rasterizationScale = UIScreen.main.scale
}
</code></pre>
<h3 id="3-避免过度更新">3. 避免过度更新</h3>
<pre><code>// 使用@StateObject而不是@ObservedObject来避免不必要的视图更新
struct ContentView: View {
  @StateObject private var viewModel = ContentViewModel()
  
  var body: some View {
    // 视图内容
  }
}
</code></pre>
<h2 id="调试和测试">调试和测试</h2>
<h3 id="1-视图层次调试">1. 视图层次调试</h3>
<pre><code>override func viewDidLoad() {
  super.viewDidLoad()
  
  // 为调试设置标识符
  view.accessibilityIdentifier = &quot;SwiftUI_Hosting_View&quot;
  
  #if DEBUG
  // 调试配置
  view.layer.borderColor = UIColor.red.cgColor
  view.layer.borderWidth = 1.0
  #endif
}
</code></pre>
<h3 id="2-测试策略">2. 测试策略</h3>
<pre><code>import XCTest

class DateDetailsHostVCTests: XCTestCase {
  
  func testHostingControllerInitialization() {
    let view = DateDetailsView(title: &quot;Test&quot;, events: [], lineWidth: 1.0)
    let hostingVC = DateDetailsHostVC(rootView: view)
    
    XCTAssertNotNil(hostingVC.view)
    XCTAssertEqual(hostingVC.rootView.title, &quot;Test&quot;)
  }
  
  func testPreferredSizeCalculation() {
    let view = DateDetailsView(title: &quot;Test&quot;, events: [], lineWidth: 1.0)
    let hostingVC = DateDetailsHostVC(rootView: view)
    
    // 触发布局
    hostingVC.loadViewIfNeeded()
    hostingVC.view.layoutIfNeeded()
    
    XCTAssertGreaterThan(hostingVC.preferredContentSize.width, 0)
    XCTAssertGreaterThan(hostingVC.preferredContentSize.height, 0)
  }
}
</code></pre>
<h2 id="与macos方案的对比">与macOS方案的对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>macOS方案</th>
<th>iOS方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心类</td>
<td><code>NSHostingView</code></td>
<td><code>UIHostingController</code></td>
</tr>
<tr>
<td>容器类型</td>
<td><code>NSViewController</code></td>
<td><code>UIViewController</code></td>
</tr>
<tr>
<td>手动布局</td>
<td>需要设置约束</td>
<td>自动管理</td>
</tr>
<tr>
<td>复杂度</td>
<td>较高</td>
<td>较低</td>
</tr>
<tr>
<td>灵活性</td>
<td>更高</td>
<td>稍低</td>
</tr>
<tr>
<td>API版本</td>
<td>macOS 10.15+</td>
<td>iOS 13.0+</td>
</tr>
</tbody>
</table>
<h2 id="注意事项">注意事项</h2>
<h3 id="1-平台兼容性">1. 平台兼容性</h3>
<ul>
<li>确保目标平台支持<code>UIHostingController</code>（iOS 13.0+）</li>
<li>考虑不同iOS版本的API差异</li>
<li>测试在不同设备尺寸下的表现</li>
</ul>
<h3 id="2-生命周期管理-3">2. 生命周期管理</h3>
<ul>
<li>注意<code>UIHostingController</code>的生命周期与SwiftUI视图的关系</li>
<li>避免在SwiftUI视图中持有对UIKit控制器的强引用</li>
<li>正确处理内存管理和资源清理</li>
</ul>
<h3 id="3-性能考虑">3. 性能考虑</h3>
<ul>
<li>避免在频繁更新的视图中使用此方案</li>
<li>考虑SwiftUI视图的复杂度对性能的影响</li>
<li>合理使用<code>@State</code>和<code>@ObservedObject</code>管理状态</li>
</ul>
<h2 id="结论">结论</h2>
<p>通过<code>UIHostingController</code>的使用，我们可以在UIKit应用中优雅地集成SwiftUI视图。相比macOS的<code>NSHostingView</code>方案，iOS的<code>UIHostingController</code>提供了更加简洁和自动化的解决方案。</p>
<p>iOS方案的主要优势：</p>
<ul>
<li><strong>简洁性</strong>：无需手动创建宿主视图和设置约束</li>
<li><strong>自动化</strong>：自动管理SwiftUI视图的尺寸和布局</li>
<li><strong>标准化</strong>：遵循iOS标准的视图控制器模式</li>
<li><strong>集成性</strong>：与iOS生态系统无缝集成</li>
</ul>
<p>对于需要在UIKit应用中使用SwiftUI的开发者来说，<code>UIHostingController</code>是一种值得推荐的技术方案。随着SwiftUI的不断发展和完善，这种混合架构的应用场景将会越来越广泛。掌握这种技术，将帮助开发者更好地利用两个框架的优势，构建出更加优秀的iOS应用程序。</p>
<hr>
<p><em>本文基于Apple官方文档和最佳实践编写，适用于iOS 13.0+版本。在实际项目中，请根据具体需求选择合适的集成方案。</em></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0">技术方案概述</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90">核心组件解析</a>
<ul>
<li><a href="#1-uihostingcontrollerswiftui%E5%88%B0uikit%E7%9A%84%E6%A1%A5%E6%A2%81">1. UIHostingController：SwiftUI到UIKit的桥梁</a></li>
<li><a href="#2-%E4%B8%8Emacos%E6%96%B9%E6%A1%88%E7%9A%84%E5%B7%AE%E5%BC%82">2. 与macOS方案的差异</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82">实现细节</a>
<ul>
<li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F">1. 基本实现模式</a></li>
<li><a href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86">2. 生命周期管理</a></li>
<li><a href="#3-%E5%B0%BA%E5%AF%B8%E7%AE%A1%E7%90%86">3. 尺寸管理</a></li>
<li><a href="#4-%E4%B8%8Euipopovercontroller%E7%9A%84%E9%9B%86%E6%88%90">4. 与UIPopoverController的集成</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">高级特性</a>
<ul>
<li><a href="#1-uihostingcontrollersizingoptions">1. UIHostingControllerSizingOptions</a></li>
<li><a href="#2-uihostingconfiguration">2. UIHostingConfiguration</a></li>
<li><a href="#3-%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1">3. 双向通信</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE">最佳实践建议</a>
<ul>
<li><a href="#1-%E5%AE%BF%E4%B8%BB%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1">1. 宿主控制器设计</a></li>
<li><a href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86-2">2. 生命周期管理</a></li>
<li><a href="#3-%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%B8%83%E5%B1%80">3. 尺寸和布局</a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">性能优化建议</a>
<ul>
<li><a href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">1. 内存管理</a></li>
<li><a href="#2-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96">2. 渲染优化</a></li>
<li><a href="#3-%E9%81%BF%E5%85%8D%E8%BF%87%E5%BA%A6%E6%9B%B4%E6%96%B0">3. 避免过度更新</a></li>
</ul>
</li>
<li><a href="#%E8%B0%83%E8%AF%95%E5%92%8C%E6%B5%8B%E8%AF%95">调试和测试</a>
<ul>
<li><a href="#1-%E8%A7%86%E5%9B%BE%E5%B1%82%E6%AC%A1%E8%B0%83%E8%AF%95">1. 视图层次调试</a></li>
<li><a href="#2-%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5">2. 测试策略</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8Emacos%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94">与macOS方案的对比</a></li>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>
<ul>
<li><a href="#1-%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7">1. 平台兼容性</a></li>
<li><a href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86-3">2. 生命周期管理</a></li>
<li><a href="#3-%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91">3. 性能考虑</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lijianfei.com/post/zai-appkit-zhong-you-ya-di-ji-cheng-swiftui-shi-tu-nshostingview-yu-nsviewcontroller-de-shi-jian-zhi-nan/">
              <h3 class="post-title">
                在AppKit中优雅地集成SwiftUI视图：NSHostingView与NSViewController的实践指南
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lijianfei.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
