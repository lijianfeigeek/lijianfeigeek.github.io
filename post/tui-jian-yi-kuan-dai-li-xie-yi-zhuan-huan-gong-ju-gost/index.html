<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>推荐一款代理协议转换工具 gost | lijianfei.com</title>
<link rel="shortcut icon" href="https://lijianfei.com/favicon.ico?v=1761120781074">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lijianfei.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="推荐一款代理协议转换工具 gost | lijianfei.com - Atom Feed" href="https://lijianfei.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<script id="chatway" async="true" src="https://cdn.chatway.app/widget.js?id=laNLrbQJYsup"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5152652314157130"
     crossorigin="anonymous">
</script>

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "m0j4678d23");
</script>
     


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74398720-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74398720-1');
</script>


    <meta property="og:title" content="推荐一款代理协议转换工具 gost">
    <meta property="og:description" content="使用 gost 可以有效解决有些软件只能使用特定协议代理协议。


README
https://github.com/ginuerzh/gost/blob/master/README.md
我的使用
详细的使用方法，官方README已经写...">
    <meta property="og:type" content="Mac App">
    <meta property="og:url" content="https://lijianfei.com/post/tui-jian-yi-kuan-dai-li-xie-yi-zhuan-huan-gong-ju-gost/">
    <meta property="og:image" content="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/2024-04-12-18-00-20.png"/>
    <meta property="og:image:width" content="800">
    <meta property="og:image:height" content="500">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@lijianfei_com">
    <meta name="twitter:title" content="推荐一款代理协议转换工具 gost">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/2024-04-12-18-00-20.png">
    <meta name="twitter:image:width" content="800">

    <meta name="description" content="使用 gost 可以有效解决有些软件只能使用特定协议代理协议。


README
https://github.com/ginuerzh/gost/blob/master/README.md
我的使用
详细的使用方法，官方README已经写..." />
    <meta name="keywords" content="Mac App" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lijianfei.com">
  <img class="avatar" src="https://lijianfei.com/images/avatar.png?v=1761120781074" alt="">
  </a>
  <h1 class="site-title">
    lijianfei.com
  </h1>
  <p class="site-description">
    思危，思退，思变。<br>
追求进步，不求完美。<br>
做好小事，熬过难事，静成大事。<br>
语以泄败，事以密成，沉得住气，静得下心。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于我
        </a>
      
    
      
        <a href="https://github.com/lijianfeigeek" class="menu" target="_blank">
          Github
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
    <img src="https://ghchart.rshah.org/F15406/lijianfeigeek" style="max-width: 100%;height: auto;"/>
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              推荐一款代理协议转换工具 gost
            </h2>
            <div class="post-info">
              <span>
                2024-02-13
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://lijianfei.com/tag/mac-app/" class="post-tag">
                  # Mac App
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/2024-04-12-18-00-20.png" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>使用 gost 可以有效解决有些软件只能使用特定协议代理协议。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/c418659c83426619df9ef71f918c8526.jpg" alt="c418659c83426619df9ef71f918c8526" loading="lazy"></figure>
<h2 id="readme">README</h2>
<p>https://github.com/ginuerzh/gost/blob/master/README.md</p>
<h2 id="我的使用">我的使用</h2>
<p>详细的使用方法，官方README已经写的很清楚了。</p>
<p>这里主要记录一下我的使用路径。</p>
<h3 id="网络协议-socks5-tls">网络协议 SOCKS5 + TLS</h3>
<p>Socks5代理自身是一个网络协议，它允许客户端通过代理服务器与目标服务器进行通信，而TLS是一种广泛使用的加密协议，旨在为互联网通信提供安全和数据保护。</p>
<h4 id="socks5代理的特点">Socks5代理的特点</h4>
<p>不加密：Socks5代理本身不提供加密功能，它只是简单地转发数据包。这意味着如果不结合其他加密手段，通过Socks5代理传输的数据可以被中间人攻击者截获和查看。<br>
支持认证：Socks5支持用户认证，这提供了一定程度上的安全性，但这并不涉及数据传输的加密。</p>
<h4 id="tls的作用">TLS的作用</h4>
<p>加密通信：TLS通过对数据进行加密，确保数据在客户端与服务器之间传输过程的隐私性和完整性，即使数据通过了Socks5代理，只要使用了TLS，数据仍然是加密的。<br>
防篡改：TLS还提供数据完整性检查，防止数据在传输过程中被篡改。</p>
<h4 id="结合使用socks5和tls的安全性">结合使用Socks5和TLS的安全性</h4>
<p>🔒当Socks5代理与TLS结合使用时，可以提供较高的安全性。Socks5负责将数据包从客户端转发到目标服务器，而TLS确保这些数据包在传输过程中被加密，从而保护了数据的隐私性和完整性。这种组合可以有效防止中间人攻击，因为即使攻击者能够截获通过Socks5代理传输的数据，由于TLS的加密，他们也无法阅读或篡改这些数据。</p>
<h3 id="gost-命令">gost 命令</h3>
<pre><code>xxxx=端口
cert和key 放文件路径
secrets为认证信息

gost -L=&quot;socks5+tls://:xxxx?cert=/cert.pem&amp;key=/key.pem&amp;secrets=/secrets.txt&quot;
</code></pre>
<p>https 证书大家自行搜索，很多服务厂家都提供。</p>
<p>secrets.txt文件格式为按行分割的认证信息，每一行认证信息为用空格分割的user-pass对，以 # 开始的行为注释行。</p>
<pre><code># period for live reloading
reload      10s

# username password

admin           #123456
test\user001    123456
test.user@002   12345678
</code></pre>
<p>reload - 此配置文件支持热更新。此选项用来指定文件检查周期，默认关闭热更新。</p>
<h3 id="macos-查询使用xxx端口的程序并杀死">macOS 查询使用xxx端口的程序，并杀死</h3>
<p>在macOS上查询使用443端口的程序并杀死这个程序，可以通过以下几个步骤来完成：</p>
<ol>
<li>
<p><strong>查询使用443端口的程序</strong>：可以使用<code>lsof</code>命令加上<code>-i</code>选项来查找使用指定端口的程序。<code>lsof</code>是一个列出当前系统打开文件的工具，其中网络连接也被视作“打开的文件”。</p>
</li>
<li>
<p><strong>杀死进程</strong>：一旦找到使用该端口的进程，可以使用<code>kill</code>命令来杀死这个进程。如果进程不愿意终止，可以尝试<code>kill -9</code>来强制杀死进程。</p>
</li>
</ol>
<p>以下是具体的步骤和命令：</p>
<p>首先，打开终端(Terminal)，然后运行以下命令来查询使用443端口的程序：</p>
<pre><code>lsof -i :443
</code></pre>
<p>这条命令会列出所有使用443端口的进程信息，包括进程的ID（PID）。</p>
<p>然后，根据上一步骤中获取到的PID，使用<code>kill</code>命令来杀死进程。例如，如果进程ID是1234，那么运行：</p>
<pre><code>kill 1234
</code></pre>
<p>如果进程拒绝被杀死，可以使用：</p>
<pre><code>kill -9 1234
</code></pre>
<p>请谨慎使用<code>kill -9</code>，因为这会立即终止进程，可能会导致数据丢失或其他问题。</p>
<p>以上步骤将帮助你在macOS上查询并杀死使用443端口的程序。记得在执行这些操作前确认该进程是否可以安全终止，以避免不必要的服务中断。</p>
<h3 id="macos-如何开机启动某个shell-命令">macOS 如何开机启动某个shell 命令</h3>
<p>在macOS上设置开机启动某个shell命令，通常可以通过使用&quot;登录项&quot;或者创建一个&quot;Launch Agent&quot;来实现。以下是两种方法的详细步骤：</p>
<h4 id="方法1使用登录项">方法1：使用&quot;登录项&quot;</h4>
<ol>
<li><strong>创建一个脚本文件</strong>：首先，你需要创建一个包含你想运行的shell命令的脚本文件。假设我们的命令是<code>echo &quot;Hello, World!&quot;</code>，你可以创建一个名为<code>startup_command.sh</code>的文件，并在文件中写入以下内容：</li>
</ol>
<pre><code>#!/bin/bash
echo &quot;Hello, World!&quot;
</code></pre>
<ol start="2">
<li>
<p><strong>使脚本可执行</strong>：通过在终端执行<code>chmod +x /path/to/startup_command.sh</code>命令来使脚本可执行，其中<code>/path/to/startup_command.sh</code>是脚本文件的路径。</p>
</li>
<li>
<p><strong>添加到登录项</strong>：打开“系统偏好设置” &gt; “用户与群组” &gt; 选择当前用户 &gt; “登录项”标签页，点击&quot;+&quot;，然后浏览并选择你的脚本文件。这样，每次登录时脚本就会被执行。</p>
</li>
</ol>
<h4 id="方法2创建一个launch-agent">方法2：创建一个Launch Agent</h4>
<ol>
<li>
<p><strong>创建plist文件</strong>：Launch Agent是通过plist（属性列表文件）配置的，这个文件定义了何时以及如何启动特定的程序或脚本。你需要在<code>~/Library/LaunchAgents</code>目录下创建一个plist文件。例如，<code>com.user.startupcommand.plist</code>。</p>
</li>
<li>
<p><strong>配置plist文件</strong>：编辑你的plist文件，加入如下配置：</p>
</li>
</ol>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.user.startupcommand&lt;/string&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/path/to/your_script.sh&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>将<code>/path/to/your_script.sh</code>替换为你的脚本文件路径。这个配置会在每次用户登录时执行脚本。</p>
<ol start="3">
<li><strong>加载Launch Agent</strong>：使用以下命令加载你的Launch Agent：</li>
</ol>
<pre><code>launchctl load ~/Library/LaunchAgents/com.user.startupcommand.plist
</code></pre>
<p>如果你希望在系统启动时而不仅仅是用户登录时执行命令，你可能需要将plist文件放在<code>/Library/LaunchDaemons</code>目录下，并确保它具有适当的权限。</p>
<h3 id="如何在后台运行某个shell-脚本">如何在后台运行某个shell 脚本</h3>
<p>在macOS或其他Unix-like系统中，将某个shell脚本在后台运行的常用方法是使用<code>&amp;</code>符号。当你在命令行中执行脚本或命令时，在命令的末尾添加<code>&amp;</code>，系统会将该命令置于后台执行。这样，你就可以继续在同一个终端会话中执行其他命令，而无需等待之前的命令完成。下面是具体步骤和示例：</p>
<h4 id="在后台运行脚本的步骤">在后台运行脚本的步骤</h4>
<ol>
<li><strong>确保脚本可执行</strong>：首先，你需要确保你的脚本是可执行的。你可以通过在终端中运行以下命令来给予脚本执行权限：</li>
</ol>
<pre><code class="language-bash">chmod +x /path/to/your_script.sh
</code></pre>
<p>这里的<code>/path/to/your_script.sh</code>是你脚本文件的路径。</p>
<ol start="2">
<li><strong>在后台运行脚本</strong>：然后，在终端中使用以下命令来在后台运行你的脚本：</li>
</ol>
<pre><code class="language-bash">/path/to/your_script.sh &amp;
</code></pre>
<p>添加<code>&amp;</code>符号会使得该脚本在后台运行。</p>
<h4 id="查看后台进程">查看后台进程</h4>
<ul>
<li>运行<code>jobs</code>命令可以查看当前会话中所有在后台运行的任务。</li>
<li>使用<code>bg</code>命令可以将一个在前台暂停的任务切换到后台继续运行。</li>
<li>使用<code>fg</code>命令可以将后台任务带回到前台继续运行。</li>
</ul>
<h4 id="管理后台运行的脚本">管理后台运行的脚本</h4>
<p>如果你想让脚本即使在关闭终端后也能继续运行，可以使用<code>nohup</code>命令。<code>nohup</code>命令可以使得运行的命令忽略挂起信号，这意味着即使终端被关闭，运行的进程也不会被终止：</p>
<pre><code>nohup /path/to/your_script.sh &amp;
</code></pre>
<p>运行这个命令后，输出通常会被重定向到名为<code>nohup.out</code>的文件中，除非你手动指定了输出文件。</p>
<h3 id="手动指定了输出文件">手动指定了输出文件</h3>
<p>如果你想在使用<code>nohup</code>命令运行脚本的同时手动指定输出文件，你可以通过重定向标准输出（stdout）和标准错误输出（stderr）来实现。这不仅可以帮助你保存脚本的运行结果，还能让你更好地管理和查看脚本产生的输出。以下是具体的步骤和示例：</p>
<h4 id="使用nohup命令手动指定输出文件">使用<code>nohup</code>命令手动指定输出文件</h4>
<ol>
<li><strong>基本语法</strong>：</li>
</ol>
<pre><code class="language-bash">nohup /path/to/your_script.sh &gt; /path/to/your_output.log 2&gt;&amp;1 &amp;
</code></pre>
<p>这里的<code>/path/to/your_script.sh</code>是你的脚本路径，<code>/path/to/your_output.log</code>是你希望将输出重定向到的文件路径。</p>
<ol start="2">
<li><strong>解析命令</strong>：</li>
</ol>
<ul>
<li><code>nohup</code>：使得命令可以在退出终端后继续运行。</li>
<li><code>/path/to/your_script.sh</code>：你想要在后台运行的脚本。</li>
<li><code>&gt;</code>：重定向标准输出到指定的文件。</li>
<li><code>/path/to/your_output.log</code>：脚本运行的输出将会保存到这个文件。</li>
<li><code>2&gt;&amp;1</code>：将标准错误输出（stderr）重定向到标准输出（stdout），这意味着错误信息也会被写入到<code>your_output.log</code>文件中。（我并没有使用这个参数，因为我需要记录全部的日志）</li>
<li><code>&amp;</code>：将命令置于后台执行。</li>
</ul>
<ol start="3">
<li><strong>示例</strong>：</li>
</ol>
<p>假设你有一个脚本<code>script.sh</code>，你想在后台运行它并将输出保存到<code>output.log</code>中，你可以这样做：</p>
<pre><code>nohup ~/scripts/script.sh &gt; ~/logs/output.log 2&gt;&amp;1 &amp;
</code></pre>
<p>这个命令会在你的用户目录下的<code>logs</code>文件夹中创建一个<code>output.log</code>文件，其中包含了脚本的输出内容，包括任何错误信息。</p>
<h3 id="自动创建时间为文件名的日志文件">自动创建时间为文件名的日志文件</h3>
<p>要自动创建以当前时间为文件名的日志文件，并在运行脚本时将输出重定向到该文件，你可以在shell脚本中使用日期命令（<code>date</code>）结合文件重定向。以下是具体步骤和一个示例：</p>
<h4 id="步骤">步骤</h4>
<ol>
<li>
<p><strong>定义日志文件的文件名</strong>：使用<code>date</code>命令和格式字符串来定义日志文件的命名方式。例如，使用<code>+%Y-%m-%d-%H%M%S</code>格式字符串可以生成一个包含年、月、日、小时、分钟和秒的时间戳。</p>
</li>
<li>
<p><strong>重定向输出到该日志文件</strong>：在脚本或命令行中，将标准输出（stdout）和标准错误（stderr）重定向到使用<code>date</code>命令生成的文件名。</p>
</li>
</ol>
<h4 id="示例">示例</h4>
<p>假设你有一个脚本<code>script.sh</code>，你想在执行时自动创建一个日志文件，文件名包含执行时的日期和时间，你可以这样做：</p>
<pre><code>#!/bin/bash
# 获取当前时间，格式为YYYY-MM-DD-HHMMSS
LOGFILE=/Users/lijianfei/Desktop/socks5_tls/$(date &quot;+%Y-%m-%d-%H%M%S&quot;).log

# 运行你的命令，并将输出重定向到日志文件
echo &quot;执行一些操作&quot; &gt; &quot;$LOGFILE&quot;
# 例如，假设你的脚本内容是打印一些信息
echo &quot;Hello, World!&quot; &gt;&gt; &quot;$LOGFILE&quot;

# 你可以在这里添加更多命令，并确保它们的输出也重定向到LOGFILE
</code></pre>
<p>在这个示例中，<code>LOGFILE</code>变量定义了日志文件的路径和名称，它包括执行脚本时的日期和时间。这样，每次运行脚本时都会创建一个新的日志文件，其文件名反映了脚本运行的确切时间。</p>
<p>要运行这个脚本并自动创建日志文件，确保脚本有执行权限：</p>
<pre><code>chmod +x /path/to/your_script.sh
</code></pre>
<p>然后运行脚本：</p>
<pre><code>/path/to/your_script.sh
</code></pre>
<p>这将在指定目录下创建一个以当前时间为名的日志文件，并包含脚本的输出。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#readme">README</a></li>
<li><a href="#%E6%88%91%E7%9A%84%E4%BD%BF%E7%94%A8">我的使用</a>
<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-socks5-tls">网络协议 SOCKS5 + TLS</a>
<ul>
<li><a href="#socks5%E4%BB%A3%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9">Socks5代理的特点</a></li>
<li><a href="#tls%E7%9A%84%E4%BD%9C%E7%94%A8">TLS的作用</a></li>
<li><a href="#%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8socks5%E5%92%8Ctls%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7">结合使用Socks5和TLS的安全性</a></li>
</ul>
</li>
<li><a href="#gost-%E5%91%BD%E4%BB%A4">gost 命令</a></li>
<li><a href="#macos-%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8xxx%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%9D%80%E6%AD%BB">macOS 查询使用xxx端口的程序，并杀死</a></li>
<li><a href="#macos-%E5%A6%82%E4%BD%95%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%9F%90%E4%B8%AAshell-%E5%91%BD%E4%BB%A4">macOS 如何开机启动某个shell 命令</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%951%E4%BD%BF%E7%94%A8%E7%99%BB%E5%BD%95%E9%A1%B9">方法1：使用&quot;登录项&quot;</a></li>
<li><a href="#%E6%96%B9%E6%B3%952%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAlaunch-agent">方法2：创建一个Launch Agent</a></li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%9F%90%E4%B8%AAshell-%E8%84%9A%E6%9C%AC">如何在后台运行某个shell 脚本</a>
<ul>
<li><a href="#%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E6%AD%A5%E9%AA%A4">在后台运行脚本的步骤</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B">查看后台进程</a></li>
<li><a href="#%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC">管理后台运行的脚本</a></li>
</ul>
</li>
<li><a href="#%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E4%BA%86%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6">手动指定了输出文件</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8nohup%E5%91%BD%E4%BB%A4%E6%89%8B%E5%8A%A8%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6">使用<code>nohup</code>命令手动指定输出文件</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4%E4%B8%BA%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">自动创建时间为文件名的日志文件</a>
<ul>
<li><a href="#%E6%AD%A5%E9%AA%A4">步骤</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lijianfei.com/post/chong-bang-lai-xi-ping-guo-jiang-zai-zai-mei-guo-kai-fang-di-san-fang-zhi-fu/">
              <h3 class="post-title">
                重磅来袭：苹果将在美国开放第三方支付
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lijianfei.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
