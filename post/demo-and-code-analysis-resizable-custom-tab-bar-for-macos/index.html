<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SwiftUI：Demo and code review for Resizable Custom Tab Bar for macOS | lijianfei.com</title>
<link rel="shortcut icon" href="https://lijianfei.com/favicon.ico?v=1761120781074">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://lijianfei.com/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="SwiftUI：Demo and code review for Resizable Custom Tab Bar for macOS | lijianfei.com - Atom Feed" href="https://lijianfei.com/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<script id="chatway" async="true" src="https://cdn.chatway.app/widget.js?id=laNLrbQJYsup"></script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5152652314157130"
     crossorigin="anonymous">
</script>

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "m0j4678d23");
</script>
     


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-74398720-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-74398720-1');
</script>


    <meta property="og:title" content="SwiftUI：Demo and code review for Resizable Custom Tab Bar for macOS">
    <meta property="og:description" content="Run in Xcode 15

1. 效果展示

2. 代码
2.1 入口

2.2 ContentView

2.3 CustomTabView

3. 代码解析
3.1 入口代码里能有什么？
3.1.1 Protocol 之 App
...">
    <meta property="og:type" content="SwiftUI">
    <meta property="og:url" content="https://lijianfei.com/post/demo-and-code-analysis-resizable-custom-tab-bar-for-macos/">
    <meta property="og:image" content=""/>
    <meta property="og:image:width" content="800">
    <meta property="og:image:height" content="500">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@lijianfei_com">
    <meta name="twitter:title" content="SwiftUI：Demo and code review for Resizable Custom Tab Bar for macOS">
    <meta name="twitter:image" content="">
    <meta name="twitter:image:width" content="800">

    <meta name="description" content="Run in Xcode 15

1. 效果展示

2. 代码
2.1 入口

2.2 ContentView

2.3 CustomTabView

3. 代码解析
3.1 入口代码里能有什么？
3.1.1 Protocol 之 App
..." />
    <meta name="keywords" content="SwiftUI" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://lijianfei.com">
  <img class="avatar" src="https://lijianfei.com/images/avatar.png?v=1761120781074" alt="">
  </a>
  <h1 class="site-title">
    lijianfei.com
  </h1>
  <p class="site-description">
    思危，思退，思变。<br>
追求进步，不求完美。<br>
做好小事，熬过难事，静成大事。<br>
语以泄败，事以密成，沉得住气，静得下心。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于我
        </a>
      
    
      
        <a href="https://github.com/lijianfeigeek" class="menu" target="_blank">
          Github
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
    <img src="https://ghchart.rshah.org/F15406/lijianfeigeek" style="max-width: 100%;height: auto;"/>
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              SwiftUI：Demo and code review for Resizable Custom Tab Bar for macOS
            </h2>
            <div class="post-info">
              <span>
                2023-11-04
              </span>
              <span>
                16 min read
              </span>
              
                <a href="https://lijianfei.com/tag/swiftui/" class="post-tag">
                  # SwiftUI
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>Run in Xcode 15</p>
<!-- more -->
<h2 id="1-效果展示">1. 效果展示</h2>
<p><video src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/6838cee2589b98a78f54149ec0a1bd44.mp4" autoplay controls loop style="max-width:100%; height:auto;"></video></p>
<h2 id="2-代码">2. 代码</h2>
<h3 id="21-入口">2.1 入口</h3>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/Ebvj3N.png" alt="" loading="lazy"></figure>
<h3 id="22-contentview">2.2 ContentView</h3>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/z4mVCh.png" alt="" loading="lazy"></figure>
<h3 id="23-customtabview">2.3 CustomTabView</h3>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/TneBhd.png" alt="" loading="lazy"></figure>
<h2 id="3-代码解析">3. 代码解析</h2>
<h3 id="31-入口代码里能有什么">3.1 入口代码里能有什么？</h3>
<h4 id="311-protocol-之-app">3.1.1 Protocol 之 App</h4>
<p>符合此协议的类型提供了应用程序的结构和行为。</p>
<p>当应用程序启动时，SwiftUI从静态主函数调用应用程序初始化器。</p>
<p>这里我们不需要在应用程序类型中实现初始化器，因为Swift默认已经合成了一个初始化器。</p>
<p>依靠该初始化器是可以的，但如果我们想创建一个，我们可以这样做：<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/Sf7wFB.png" alt="" loading="lazy"></p>
<h4 id="312-main">3.1.2 @main</h4>
<p>当我们声明的应用程序类型用@main注释时，将调用其静态main()函数。</p>
<p>默认实现以适合平台的方式启动应用程序。我们想在启动时加点什么，我们可以这样做：<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/LYRe4h.png" alt="" loading="lazy"></p>
<h4 id="313-那么我们之前的appdelegate的那些回调函数去哪儿了">3.1.3 那么我们之前的AppDelegate的那些回调函数去哪儿了？</h4>
<p>答案是在 @UIApplicationDelegateAdaptor 和 @NSApplicationDelegateAdaptor</p>
<p>让我们以 @UIApplicationDelegateAdaptor 为例子</p>
<p>UIApplicationDelegateAdaptor是一个属性包装器（注解），用于为使用新的SwiftUI生命周期的应用程序提供应用程序委托。使用此属性包装器是可选的，因为应用程序不再需要委托。</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/w2c1dF.png" alt="" loading="lazy"></figure>
<h4 id="314-什么是-scene">3.1.4 什么是 Scene</h4>
<p>Scene 场景代表屏幕上的内容区域。每个平台使用场景的方式不同。</p>
<p>在iOS上，屏幕通常包含单个场景，在 iPadOS 通常会有多个场景，例如在使用分屏浏览时，可能会显示多个场景。</p>
<p>在macOS上，每个窗口可能是不同的场景。场景也可以有子场景。例如，在macOS上，每个窗口都是一个场景，但当所有窗口合并到一个具有多个选项卡的窗口中时，每个选项卡仍然有一个场景和另一个包含它们的场景。</p>
<p>可以通过遵守场景协议来创建自定义场景。唯一的要求是实现主体（body）。主体由其他场景组成，这些场景也可以是自定义场景或：WindowGroup、DocumentGroup和Settings。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/Kp9bMK.png" alt="" loading="lazy"></figure>
<h4 id="315-什么是-windowgroup">3.1.5 什么是 WindowGroup</h4>
<p>WindowGroup 符合Scene协议，是SwiftUI框架提供的具体类型。其他场景类型有： DocumentGroup, Settings 和WKNotificationScene等；<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/9SjwQd.png" alt="" loading="lazy"></p>
<p><code>WindowGroup</code> 是用于呈现一组结构相同的窗口的场景。尽管它们的结构相同，但每个场景和视图层次都有自己的状态。SwiftUI 能够处理不同平台的特定行为，例如在 macOS 和 iPadOS 上同时打开多个窗口。在 macOS 13.0 之前，可以使用一些方法打开新窗口，但从 macOS 13.0 开始，引入了新的环境值 <code>openWindow</code> 来增强 <code>WindowGroup</code> 的功能。<code>WindowGroup</code> 的初始化器有多种，它们可以包含不同类型的标题或 <code>id</code> 参数，并可以为窗口指定默认值。标题用于在用户界面中区分窗口组。<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/1u9BmB.png" alt="" loading="lazy"></p>
<h3 id="32-contentview-大有学问">3.2 ContentView 大有学问</h3>
<p>状态管理，我们按下不表，我记得之前写过几篇状态管理的文章。iOS 17推出了新的状态管理方式，后面我会再写一篇自己的理解。</p>
<h4 id="321-geometryreader-是什么">3.2.1 GeometryReader 是什么？</h4>
<p><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/WvYbqO.png" alt="" loading="lazy"><br>
<code>GeometryReader</code> 是 SwiftUI 中的一个视图容器，它用于获取其子视图的几何属性，例如大小和位置。</p>
<p>重点：它为其内容提供了一个包含尺寸信息的上下文，从而允许我们根据父视图的尺寸动态调整子视图的布局。</p>
<p>用法示例：<br>
下面是一个简单的示例，它使用 <code>GeometryReader</code> 来创建一个正方形视图，其边长等于父视图的宽度的一半。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/QhecBY.png" alt="" loading="lazy"></figure>
<p>额外注意：</p>
<ul>
<li><strong>性能考虑</strong>：<code>GeometryReader</code> 可能会导致布局的重新计算，因此应该谨慎使用，以避免不必要的性能开销。（在开始前写代码前考虑性能优化的优先级较低，可以先不考虑，等出现了性能问题我们再说）</li>
<li><strong>布局行为</strong>：<code>GeometryReader</code> 的尺寸会尽可能的填充其父视图的可用空间。</li>
</ul>
<p>用途：<br>
<code>GeometryReader</code> 在需要根据父视图的尺寸动态调整视图布局时非常有用，例如创建响应式设计、自适应布局等。</p>
<h4 id="322-为什么-0">3.2.2 为什么 $0？</h4>
<p>在 Swift 中，<code>$0</code> 是一个用于表示闭包（closure）中的第一个参数的快捷方式。当闭包的参数没有显式命名时，可以使用 <code>$0</code>、<code>$1</code>、<code>$2</code> 等来引用闭包的第一个、第二个、第三个参数，以此类推。这种写法可以让代码更简洁。</p>
<pre><code>GeometryReader {  // 用于获取当前视图的尺寸信息
    let size = $0.size  // 获取当前视图的尺寸
</code></pre>
<p><code>GeometryReader</code> 接受一个闭包，该闭包的参数是一个 <code>GeometryProxy</code> 对象，它包含了当前视图的尺寸信息。通常，我们可以显式地命名这个参数，如下所示：</p>
<pre><code>GeometryReader { geometry in
    let size = geometry.size
</code></pre>
<p>但为了简洁，我们代码使用了 <code>$0</code> 来代替 <code>geometry</code>。两种写法的功能是相同的，只是语法上的不同。</p>
<h4 id="323-viewthatfits-又是什么">3.2.3 ViewThatFits 又是什么？</h4>
<p><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/v7vM6y.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/gKp4h8.png" alt="" loading="lazy"></p>
<p><code>ViewThatFits</code>是SwiftUI中一个非常有用的视图，它能够帮助我们根据可用的屏幕空间来选择合适的布局。具体来说，<code>ViewThatFits</code>的工作原理如下：</p>
<ol>
<li>
<p><strong>子视图评估</strong>：</p>
<ul>
<li><code>ViewThatFits</code>会按照我们提供给它的顺序来评估其子视图。</li>
<li>它会选择第一个其理想尺寸在约束轴上符合提议大小的子视图。</li>
<li>这意味着我们应该按照优先级顺序提供视图。</li>
</ul>
</li>
<li>
<p><strong>自适应布局</strong>：</p>
<ul>
<li>通过<code>ViewThatFits</code>，我们可以让它从几种可能的布局中选择一种，基于什么布局能够适应可用的屏幕空间。</li>
<li>这是一种确保你的应用程序从最大的tvOS屏幕到最小的Apple Watch都能看起来很好的方式。</li>
</ul>
</li>
<li>
<p><strong>空间测量</strong>：</p>
<ul>
<li><code>ViewThatFits</code>测量特定轴或两者的可用空间。</li>
<li>它测量第一个视图的大小并将其放置在可用空间中，如果它适合的话。</li>
<li>如果第一个视图不适合可用空间，它会测量第二个视图的大小，并在第二个视图适合的情况下将其放置。</li>
</ul>
</li>
<li>
<p><strong>响应式布局的创建</strong>：</p>
<ul>
<li>在iOS 16中，通过<code>ViewThatFits</code>，SwiftUI得以更容易地创建响应式布局。</li>
<li>响应式布局是能够适应可用空间的视图或布局。</li>
<li><code>ViewThatFits</code>是一个容器视图，它让我们定义适合不同大小的子视图列。</li>
</ul>
</li>
</ol>
<p><code>ViewThatFits</code>通过以上方式，使得创建自适应不同屏幕和设备的布局变得更为简单和直观。同时，它的使用也极大地简化了响应式布局的设计过程，使得我们能够更专注于布局的内容和交互设计，而不是在处理布局适配上消耗大量时间。</p>
<h4 id="324-viewthatfitstask-是什么">3.2.4 ViewThatFits{}.task{} 是什么</h4>
<p>在SwiftUI中，<code>.task</code> 修饰符是用来在视图显示时运行异步任务，并在视图消失时自动取消任务的。<br>
这在 iOS 15 和其它相应的平台版本中引入。它类似于以前的 <code>.onAppear</code> 修饰符，但是特别适用于执行异步任务。</p>
<p>例如，我们可以像这样使用 <code>.task</code> 修饰符：</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/KCsg8q.png" alt="" loading="lazy"></figure>
<p>在上述代码中，当 <code>ContentView</code> 出现时，<code>.task</code> 修饰符中的代码将开始执行。如果 <code>ContentView</code> 消失，那么 <code>.task</code> 中的任务将自动取消。<code>.task</code> 里的代码会被异步执行。这对于启动网络请求、读取文件等耗时操作非常有用，因为它不会阻塞主线程。</p>
<h4 id="325-为什么sidebarsize调用了2次">3.2.5 为什么SideBar(size)调用了2次？</h4>
<p><code>SideBar(size)</code>在这个代码片段中被调用了两次，分别处于不同的上下文和目的中：</p>
<ol>
<li>
<p><strong>在<code>ViewThatFits</code>中的调用</strong>：<br>
在<code>ViewThatFits</code>视图内，<code>SideBar(size)</code>被首先调用，这意味着它是<code>ViewThatFits</code>试图适配的第一个候选视图。<code>ViewThatFits</code>会检查<code>SideBar(size)</code>是否能够适应当前的视图尺寸，如果可以，它就会被选择和显示。<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/fAdsXe.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>在<code>ScrollView</code>中的调用</strong>：<br>
在<code>ScrollView</code>内，<code>SideBar(size)</code>再次被调用。这次，它是作为一个可以滚动的内容视图。如果<code>SideBar(size)</code>的内容超出了<code>ScrollView</code>的可视区域，用户可以滚动来查看其余的内容。</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/kudBmP.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>这种设计方式提供了一个灵活的布局，可以在不同的上下文和条件下适应<code>SideBar</code>视图。例如，当视图的宽度大于屏幕宽度的一半时（<code>isLarge</code>为<code>true</code>），<code>SideBar</code>视图可能直接在<code>ViewThatFits</code>内显示，而不需要滚动。相反，如果视图的宽度较小（<code>isLarge</code>为<code>false</code>），<code>SideBar</code>视图可能会在<code>ScrollView</code>内显示，允许用户滚动来查看全部内容。</p>
<p>这种方式为开发者提供了一种机制，根据不同的设备和屏幕尺寸展示不同的布局或适应不同的用户界面设计，以实现更好的用户体验。</p>
<h4 id="326-新手问这样-sidebar-不就被渲染了两次吗为什么没有同时出现两个-sidebar核心问题">3.2.6 [新手问]这样 SideBar 不就被渲染了两次吗？为什么没有同时出现两个 SideBar？[核心问题]</h4>
<p>在<code>ViewThatFits</code>中，<code>SideBar</code>和<code>ScrollView</code>中的<code>SideBar</code>是作为两个可能的布局选项提供的，但是<code>ViewThatFits</code>会根据提供的条件和空间选择其中一个布局。<code>ViewThatFits</code>的工作原理是，它会评估其子视图（在这种情况下是<code>SideBar</code>和<code>ScrollView</code>中的<code>SideBar</code>），并选择第一个其理想尺寸在约束轴上符合提议大小的子视图。这意味着，只有一个布局会被选择并渲染到屏幕上，而另一个布局则会被忽略。</p>
<p>在我们的代码中：</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/XMYGaG.png" alt="" loading="lazy"></figure>
<ul>
<li>如果<code>SideBar(size)</code>的尺寸适合当前的视图空间，它将被选择并渲染，而<code>ScrollView</code>中的<code>SideBar</code>将不会被渲染。</li>
<li>如果<code>SideBar(size)</code>的尺寸不适合当前的视图空间，<code>ViewThatFits</code>将继续评估<code>ScrollView</code>中的<code>SideBar</code>，如果它适合，则它将被选择并渲染。</li>
</ul>
<p>因此，虽然<code>SideBar(size)</code>被调用了两次，但是只有一个<code>SideBar</code>实例会被渲染到屏幕上。这是通过<code>ViewThatFits</code>的自适应布局逻辑实现的，它确保了在任何给定时间只有一个布局被选择和渲染。</p>
<h4 id="327-什么是viewbuilder什么情况下才使用viewbuilder">3.2.7 什么是@ViewBuilder？什么情况下才使用@ViewBuilder？</h4>
<p><code>@ViewBuilder</code> 是 SwiftUI 中的一个特性，它允许我们在函数或者计算属性中构建和返回一个动态的视图集合。</p>
<p>使用 <code>@ViewBuilder</code>，我们可以基于条件或循环创建视图，并且它们将被自动组合成一个单一的视图。<code>@ViewBuilder</code> 是一个函数修饰符，它可以将函数体中的多个视图组合成一个复合视图，通常是一个 <code>TupleView</code> 或者某些情况下的其他类型的视图。</p>
<p>下面是一些 <code>@ViewBuilder</code> 可以被用到的情况：</p>
<ol>
<li>
<p><strong>条件视图</strong>：<br>
如果我们想基于某个条件返回不同的视图，我们可以使用 <code>@ViewBuilder</code>。例如，我们可能想要显示一个视图，如果某个条件为真，显示另一个视图，如果条件为假。<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/wMS9mY.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>循环视图</strong>：<br>
如果我们想要循环遍历一个集合并为集合中的每个元素创建一个视图，你可以使用 <code>@ViewBuilder</code>。<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/x5t32N.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>组合视图</strong>：<br>
如果我们想要组合多个视图成一个单一的视图，我们可以使用 <code>@ViewBuilder</code>。</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/UwDIs6.png" alt="" loading="lazy"></figure>
</li>
</ol>
<p>在上述的例子中，<code>@ViewBuilder</code> 修饰符允许我们在一个函数或计算属性中返回一个动态的视图集合，而不是仅仅返回一个单一的视图。它提供了一种简洁、清晰的方式来构建复杂的视图层次结构，而不需要创建大量的中间视图和辅助结构。这使得我们的代码更为简洁、可读并且更容易维护。同时，<code>@ViewBuilder</code> 的使用也可以帮助优化 SwiftUI 的渲染性能，因为它能够减少不必要的视图创建和更新。</p>
<p>这里我们再补充一些其他关于关于<code>@ViewBuilder</code>：</p>
<ol>
<li>
<p><strong>返回类型</strong>:<br>
使用 <code>@ViewBuilder</code> 修饰的函数或属性，通常会返回 <code>some View</code> 类型。这是因为 <code>@ViewBuilder</code> 可能会根据我们的代码返回不同类型的视图。例如，它可能返回一个 <code>TupleView</code>，<code>EmptyView</code> 或者我们自定义的视图类型。</p>
</li>
<li>
<p><strong>EmptyView</strong>:<br>
在条件语句中，如果某个条件分支没有对应的视图，<code>@ViewBuilder</code> 会自动使用 <code>EmptyView</code> 来填充那个分支。</p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/tY6n16.png" alt="" loading="lazy"></figure>
</li>
<li>
<p><strong>嵌套使用</strong>:<br>
我们可以嵌套使用 <code>@ViewBuilder</code>，这意味着我们可以在一个 <code>@ViewBuilder</code> 修饰的函数或属性中调用另一个 <code>@ViewBuilder</code> 修饰的函数或属性。</p>
</li>
<li>
<p><strong>复杂的逻辑</strong>:<br>
我们可以在 <code>@ViewBuilder</code> 修饰的函数或属性中使用复杂的逻辑，包括 <code>switch</code> 语句，<code>guard</code> 语句，以及更复杂的循环和条件语句。</p>
</li>
<li>
<p><strong>性能优化</strong>:<br>
<code>@ViewBuilder</code> 是 SwiftUI 的一个性能优化工具。通过减少不必要的视图更新和渲染，它可以帮助提高我们的应用程序的性能。</p>
</li>
<li>
<p><strong>自定义容器视图</strong>:<br>
<code>@ViewBuilder</code> 是创建自定义容器视图的关键。通过使用 <code>@ViewBuilder</code>，我们可以创建能够接受和布局多个子视图的自定义视图。</p>
</li>
</ol>
<p><code>@ViewBuilder</code> 是一个非常强大和灵活的工具，在 SwiftUI 中构建复杂的视图层次结构时，它是不可或缺的。</p>
<h4 id="328-oncontinuoushover-其实是一个-protocol">3.2.8 onContinuousHover 其实是一个 Protocol</h4>
<p><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/EMWTKZ.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/B1u2Mr.png" alt="" loading="lazy"></p>
<p>在 SwiftUI 中，<code>.onContinuousHover(perform:)</code> 是一个修饰符，它可以用于检测用户的鼠标或指针是否悬停在视图上，并提供持续的反馈。这个修饰符可以用于 macOS 和 iPadOS，它提供了一种简单的方式来响应用户的鼠标或指针交互。</p>
<p>在我们这段代码中：</p>
<ol>
<li>
<p><strong>phase</strong>:</p>
<ul>
<li><code>phase</code> 参数是一个 <code>HoverPhase</code> 枚举值，它指示了鼠标或指针的悬停状态。</li>
<li><code>HoverPhase</code> 有两个可能的值: <code>.hovering</code> 和 <code>.ended</code>。<code>.hovering</code> 表示鼠标或指针正在悬停在视图上，<code>.ended</code> 表示鼠标或指针已经停止悬停或离开了视图。</li>
</ul>
</li>
<li>
<p><strong>perform</strong>:</p>
<ul>
<li><code>perform</code> 闭包是当鼠标或指针的悬停状态改变时执行的代码块。我们可以在这个闭包中根据 <code>phase</code> 参数的值执行不同的操作。</li>
</ul>
</li>
</ol>
<p>这个修饰符可以用于创建响应鼠标或指针悬停的交互效果。例如，我们可能想要在用户的鼠标悬停在一个按钮上时改变按钮的颜色，或者显示一个提示信息。</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/oSA5I8.png" alt="" loading="lazy"></figure>
<p>在这个例子中，<code>.onContinuousHover</code> 修饰符用于检测用户是否悬停在按钮上，并根据悬停状态执行不同的操作。</p>
<h3 id="33-customtabview-自定义视图">3.3 CustomTabView 自定义视图</h3>
<h4 id="331-t-什么意思">3.3.1 T 什么意思？</h4>
<p>在我们这段代码中，<code>T</code> 是一个泛型参数，它代表了一个遵循 <code>Hashable</code> 协议的类型。</p>
<p>泛型<code>T</code>被用于 <code>@Binding var selection: T</code>，表示 <code>selection</code> 变量的类型是泛型 <code>T</code>，这使得 <code>CustomTabView</code> 可以处理不同类型的 <code>selection</code> 数据，只要这些类型遵循 <code>Hashable</code> 协议。</p>
<p>同时，泛型 <code>T</code> 也用于 <code>TabView(selection: $selection)</code>，以确保 <code>TabView</code> 的 <code>selection</code> 参数与 <code>CustomTabView</code> 的 <code>selection</code> 变量类型一致。</p>
<p>这样的设计使得 <code>CustomTabView</code> 有更好的灵活性和可重用性。</p>
<p>另外在 Swift 和 SwiftUI 中，<code>T</code> 并不总是代表泛型参数，但它是一个常用的约定来表示泛型参数。我们可以使用任何有效的标识符来作为泛型参数的名字，例如 <code>TypeParameter</code>，<code>Element</code>，<code>Item</code> 等。不过，<code>T</code> 作为一个简单、通用的符号，常常被用于泛型编程中，来表示一个类型参数。这个约定使得代码更简洁，也更容易被其他开发者理解。</p>
<h4 id="332-为什么使用fileprivate">3.3.2 为什么使用fileprivate？</h4>
<p>在 Swift 中，<code>fileprivate</code> 是一个访问控制修饰符，它指定某个声明只能在其定义的文件内部访问。</p>
<p>我们的代码中，<code>fileprivate</code> 修饰 <code>struct TabFinder</code> 和 <code>extension NSView</code>，意味着这两个声明只能在它们被定义的文件中访问，不能在文件的外部访问。这是一种封装的方式，确保了代码的模块化和安全性，防止了外部代码访问或修改这些内部实现。</p>
<h4 id="333-typetype-新魔法">3.3.3 Type.Type 新魔法？</h4>
<p>在代码中，<code>Type.Type</code> 是指定泛型 <code>Type</code> 的元类型。</p>
<p>在 Swift 中，每个类型都有一个与之关联的元类型，用来表示类型本身，而不是类型的实例。</p>
<p>在这个 <code>func subviews&lt;Type: NSView&gt;(type: Type.Type) -&gt; [Type]</code> 函数签名中，<code>Type.Type</code> 指定了我们想要查询的 <code>NSView</code> 子类的类型，而 <code>Type</code> 是泛型参数，代表了我们想要查询的具体 <code>NSView</code> 子类类型。</p>
<p>这个代码设计允许我们以类型安全的方式查询特定类型的子视图，而不需要对子视图的类型进行硬编码或强制类型转换。</p>
<h2 id="4-结尾">4. 结尾</h2>
<p>好了，本期的Demo 和 Code review 就结束了。我们下期再见。<br>
<img src="https://raw.githubusercontent.com/lijianfeigeek/PictureBed/main/uPic/gLIZn7.png" alt="" loading="lazy"></p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA">1. 效果展示</a></li>
<li><a href="#2-%E4%BB%A3%E7%A0%81">2. 代码</a>
<ul>
<li><a href="#21-%E5%85%A5%E5%8F%A3">2.1 入口</a></li>
<li><a href="#22-contentview">2.2 ContentView</a></li>
<li><a href="#23-customtabview">2.3 CustomTabView</a></li>
</ul>
</li>
<li><a href="#3-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90">3. 代码解析</a>
<ul>
<li><a href="#31-%E5%85%A5%E5%8F%A3%E4%BB%A3%E7%A0%81%E9%87%8C%E8%83%BD%E6%9C%89%E4%BB%80%E4%B9%88">3.1 入口代码里能有什么？</a>
<ul>
<li><a href="#311-protocol-%E4%B9%8B-app">3.1.1 Protocol 之 App</a></li>
<li><a href="#312-main">3.1.2 @main</a></li>
<li><a href="#313-%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E4%B9%8B%E5%89%8D%E7%9A%84appdelegate%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%8E%BB%E5%93%AA%E5%84%BF%E4%BA%86">3.1.3 那么我们之前的AppDelegate的那些回调函数去哪儿了？</a></li>
<li><a href="#314-%E4%BB%80%E4%B9%88%E6%98%AF-scene">3.1.4 什么是 Scene</a></li>
<li><a href="#315-%E4%BB%80%E4%B9%88%E6%98%AF-windowgroup">3.1.5 什么是 WindowGroup</a></li>
</ul>
</li>
<li><a href="#32-contentview-%E5%A4%A7%E6%9C%89%E5%AD%A6%E9%97%AE">3.2 ContentView 大有学问</a>
<ul>
<li><a href="#321-geometryreader-%E6%98%AF%E4%BB%80%E4%B9%88">3.2.1 GeometryReader 是什么？</a></li>
<li><a href="#322-%E4%B8%BA%E4%BB%80%E4%B9%88-0">3.2.2 为什么 $0？</a></li>
<li><a href="#323-viewthatfits-%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88">3.2.3 ViewThatFits 又是什么？</a></li>
<li><a href="#324-viewthatfitstask-%E6%98%AF%E4%BB%80%E4%B9%88">3.2.4 ViewThatFits{}.task{} 是什么</a></li>
<li><a href="#325-%E4%B8%BA%E4%BB%80%E4%B9%88sidebarsize%E8%B0%83%E7%94%A8%E4%BA%862%E6%AC%A1">3.2.5 为什么SideBar(size)调用了2次？</a></li>
<li><a href="#326-%E6%96%B0%E6%89%8B%E9%97%AE%E8%BF%99%E6%A0%B7-sidebar-%E4%B8%8D%E5%B0%B1%E8%A2%AB%E6%B8%B2%E6%9F%93%E4%BA%86%E4%B8%A4%E6%AC%A1%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E5%90%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E4%B8%A4%E4%B8%AA-sidebar%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98">3.2.6 [新手问]这样 SideBar 不就被渲染了两次吗？为什么没有同时出现两个 SideBar？[核心问题]</a></li>
<li><a href="#327-%E4%BB%80%E4%B9%88%E6%98%AFviewbuilder%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%89%8D%E4%BD%BF%E7%94%A8viewbuilder">3.2.7 什么是@ViewBuilder？什么情况下才使用@ViewBuilder？</a></li>
<li><a href="#328-oncontinuoushover-%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E4%B8%AA-protocol">3.2.8 onContinuousHover 其实是一个 Protocol</a></li>
</ul>
</li>
<li><a href="#33-customtabview-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE">3.3 CustomTabView 自定义视图</a>
<ul>
<li><a href="#331-t-%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D">3.3.1 T 什么意思？</a></li>
<li><a href="#332-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8fileprivate">3.3.2 为什么使用fileprivate？</a></li>
<li><a href="#333-typetype-%E6%96%B0%E9%AD%94%E6%B3%95">3.3.3 Type.Type 新魔法？</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E7%BB%93%E5%B0%BE">4. 结尾</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://lijianfei.com/post/gao-tong-oryon-xin-pian-wei-lai-shi-nian-xiao-fei-dian-zi-de-xin-wang-zhe/">
              <h3 class="post-title">
                高通Oryon芯片：未来十年，消费电子的新王者？
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://lijianfei.com/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
